이펙티브 소프트웨어 테스팅 - 마우리시오 아니시
6장 테스트 더블과 모의 객체

---

참고 작성 글
[테스트 대역 (목 과 스텁)](https://github.jonghoonpark.com/2023/05/11/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%97%AD-%EB%AA%A9-%EA%B3%BC-%EC%8A%A4%ED%85%81)

---

> 이 장은 다음과 같은 내용을 다룬다.
>
> - 스텁, 페이크, 모의 객체를 사용해서 테스트를 단순화하는 방법
> - 모의 객체가 무엇인지, 모의 객체를 언제 사용해야 하는지, 언제 사용하지 말아야 하는지에 대한 이해
> - 모의할 수 없는 객체를 모의하는 방법

어떤 클래스는 작업을 수행할 때 다른 클래스에 의존한다. 여러 클래스를 함께 수행(또는 테스트)하는 것이 바람직할 수 있다.
이 장에서는 종속성을 너무 신경 쓰지 말고 격리된 방식으로 테스트하는 데 초점을 맞춘다.

왜 이런 테스트가 필요할까?
대답은 간단하다. 테스트 대상 클래스를 구체적인 의존성과 함께 수행하는 일은 너무 느리거나, 너무 힘들거나, 너무 많은 일을 해야 할 수 있기 때문이다.

예를들어 데이터베이스를 의존하는 테스트의 경우에는 데이터베이스를 설정하고 올바른 데이터가 모두 포함되어있는지 확인하는 등 준비를 해야한다. 이로 인해 의존성이 없는 테스트에 비해 훨씬 더 많은 작업을 필요로 한다.
(만약 SQL 쿼리가 올바른지 테스트를 하고 싶다면 이것은 통합 테스트에서 해야한다.)

우리는 다른 클래스에 의존하는 클래스를 테스트할 때 의존성을 사용하지 않는 방법을 알아내야 한다. 이때 테스트 더블(test double)이 도움이 된다.

> 이 블로그에서 여러번 다뤘지만 참고로 double은 대역 이라는 뜻도 있다.

구성요소의 동작을 모방하는 객체를 생성하여 테스트 맥락에 따라 구성요소처럼 행동하도록 한다.
구성요소의 주변 환경을 제어함으로써 복잡한 종속성을 처리하지 않고 구성요소의 동작 방식을 나타낼 수 있다.

다른 객체의 동작을 시뮬레이션하는 객체를 사용하면 다음과 같은 장점이 있다.

- **더 큰 제어권** 을 가진다. 우리는 이 가짜 객체에게 무엇을 해야 할지 알려줄 수 있다. 예외를 던지는 방법을 원한다면, 그것을 모의하는 방법을 알려준다. 예외를 던지기 위해 복잡한 설정이 필요하지도 않다.
- **빠른 시뮬레이션** 이 가능하다. 종속성을 가진 클래스는 어떤 메서드를 실행하는 데 몇 초 정도 걸릴 수 있다. 반면에 종속성을 시뮬레이션하면 응답을 기다릴 필요가 없다. 시간 측면에서 비용이 들지 않는다.
- **클래스 간의 상호작용 반영**이 가능하다. 계약이 어떻게 되어야 하는지, 개념적인 경계는 어떻게 나눌 수 있을지 반영할 수 있다.

# 6.1 더미, 페이크, 스텁, 모의 객체, 스파이

## 6.1.1 더미 객체

더미는 테스트 대상 클래스에 전달되었지만 절대 사용되지 않는 객체다. 비즈니스 애플리케이션에 전달해야 할 인수가 여러 개 있지만 테스트는 이들 중 몇 개만 사용할 때 더미 객체를 사용해도 좋다. (어떤 값을 가져도 테스트에 영향이 없을 경우)

## 6.1.2 페이크 객체

페이크 객체는 시뮬레이션하려는 클래스같이 실제로 동작하는 구현체를 가진다. 하지만 똑같이 동작한다기 보다는 훨씬 단순한 방법으로 동작한다.
(책에서는 예시로 인메모리 데이터베이스를 들었는데, 단위 테스트 책에서는 인메모리 데이터베이스를 피하라고 되어있다. - [데이터베이스 테스트](https://github.jonghoonpark.com/2023/09/22/10%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8))

## 6.1.3 스텁

스텁은 테스트 과정에서 수행된 호출에 대해 하드 코딩된 응답을 제공한다. 페이크 객체와는 달리 스텁은 실제로 동작하는 구현체가 없다.

## 6.1.4 모의 객체

모의 객체는 메서드의 응답을 설정할 수 있다는 점에서 스텁 같은 역할을 한다. 하지만 모의 객체는 그 이상이다. 모의 객체는 모든 상호작용을 저장해서 나중에 단언(assert)문에서 활용할 수 있도록 해준다. (상호 작용 횟수를 저장하고 있음)

## 6.1.5 스파이

스파이는 의존성을 감시한다. 스파이는 실제 객체를 감싸서 그 행동을 관찰한다.
엄밀히 말하면 객체를 시뮬레이션하는게 아니라 감시하고 있는 근본 객체와의 모든 상호작용을 기록한다.
스파이는 특정 맥락에서 사용된다. 모의 객체를 사용하는 것보다 실제로 구현하는 게 훨씬 더 쉽고, 테스트 대상 메서드가 의존 대상ㅇ과 어떻게 상호작용하는지 단언하고 하는 경우에 사용된다. 스파이는 현업에서는 보기 힘들다.

# 6.2 모의 객체 프레임워크에 대한 소개

여기서는 모키토(mokito)를 사용한다.

모키토는 매우 간단하며 다음 세 가지 메서드만 알아도 충분하다.

**mock(\<class>)**: 주어진 클래스로 모의 객체 또는 스텁을 생성한다. 클래스는 \<ClassName>.class로 구체화한다.
**when(\<mock>.\<method>).thenReturn(\<value>)**: (스텁화된) 메서드의 동작을 정의하는 연속된 메서드 호출이다. \<value>를 반환한다.
\*\*verify(\<mock>).\<method>: 모의 객체와의 상호작용이 예상된 방식으로 일어난다고 단언한다.

예시를 통해 알아보자

## 6.2.1 의존성 스텁화

아래의 요구사항이 있다고 하자.

> 프로그램은 100보다 작은 값을 가지는 송장을 모두 반환한다. 송장은 데이터베이스에서 찾을 수 있다. IssuedInvoices 클래스는 모든 송장을 검색하는 메서드를 이미 포함하고 있다.

아래 코드는 이 요구사항을 구현한 예다.

```java
public class InvoiceFilter {
    public List<Invoice> lowValueInvoices() {
        DatabaseConntection dbConnection = new DatabaseConnection();
        IssuedInvoices issuedInvoices = new IIssuedInvoices(dbConnection);

        try {
            List<Invoice> all = issuedInvoices.all();
            return all.stream()
                    .filter(invoice -> invoice.getValue() < 100)
                    .collect(toList())
        } finally {
            dbConnection.close();
        }
    }
}
```

issuedInvoices 클래스를 스텁으로 만들지 않고 InvoiceFilter 클래스를 테스트하려면 실제 데이터베이스를 설정해야 한다.
이 방법은 작업량이 많다.

일단 위 코드에 대한 테스트 코드를 작성해보면 아래와 같이 작성 작성해볼 수 있다.

```java
public class InvoiceFilterTest {
  private IssuedInvoices invoices;
  private DatabaseConnection dbConnection;

  @BeforeEach
  public void open() {
    dbConnection = new DatabaseConnection();
    issuedInvoices = new IIssuedInvoices(dbConnection);

    dbConnection.resetDatabase();
  }

  @AfterEach
  public void close() {
    if (dbConnection != null)
      dbConnection.close();
  }

  @Test
  void filterInvoices() {
    Invoice invoice1 = new Invoice("invoice1", 20);
    Invoice invoice2 = new Invoice("invoice2", 99);
    Invoice invoice3 = new Invoice("invoice3", 100);
    invoices.save(invoice1);
    invoices.save(invoice2);
    invoices.save(invoice3);

    InvoiceFilter filter = new InvoiceFilter();

    assertThat(filter.lowvalueInvoices())
        .containsExactlyInAnyOrder(invoice1, invoice2);
  }
}
```

> containsExactlyInAnyOrder 는 AssertJ의 기능이다.

이번에는 IssudInvoices 클래스를 스텁으로 만들어서 데이터베이스와 관련된 귀찮을 일을 피해보자.

InssuedInvoice를 생성자를 통해 전달받도록 수정하자.
이렇게 리팩토링 하면 DatabaseConnection을 주입할 필요가 없어진다.

```java
public class InvoiceFilter {
    private final IssuedInvoices issuedInvoices;

    public InvoiceFilter(IssuedInvoices issuedInvoices) {
        this.issuedInvoices = issuedInvoices;
    }

    public List<Invoice> lowValueInvoices() {
        List<Invoice> all = issuedInvoices.all();
        return all.stream()
                .filter(invoice -> invoice.getValue() < 100)
                .collect(toList())
    }
}
```

위 코드에 대한 테스트 코드를 작성하면 아래와 같이 개선된다.

```java
public class InvoiceFilterTest {

  @Test
  void filterInvoices() {
    IssuedInvoices issuedInvoice = mock(IssuedInvoices.class)

    Invoice invoice1 = new Invoice("invoice1", 20);
    Invoice invoice2 = new Invoice("invoice2", 99);
    Invoice invoice3 = new Invoice("invoice3", 100);
    List<Invoice> listOfInvoices = Arrays.asList(invoice1, invoice2, invoice3)

    when(issuedInvoices.all()).thenReturn(listOfInvoices)

    InvoiceFilter filter = new InvoiceFilter(issuedInvoices);

    assertThat(filter.lowvalueInvoices())
        .containsExactlyInAnyOrder(invoice1, invoice2);
  }
}
```

모키토의 모의 메서드를 이용해서 IssuedInvoices 클래스에 대한 스텁 인스턴스를 생성한 후
all()이 호출되면 미리 정의된 송장 목록을 반환하도록 하였다.

스텁은 테스트를 쉽게 작성하도록 해줄 뿐만 아니라, 테스트 클래스를 더 응집력 있게 해주고 다른 요소의 변경으로 인한 변경을 줄여준다. 이는 테스트가 실패할 활률을 줄여준다. 테스트가 실패했을 때 개발자의 디버깅 시간도 아껴준다.

## 6.2.2 모의 객체와 기댓값

다음과 같은 새로운 요구사항이 생겼다고 가정하자

> 작은 값을 가진 송장을 모두 SAP 시스템 (비즈니스 운영 관리 시스템)으로 전송해야 한다. SAP는 송장을 받기 위해 sendInvoice 웹 서비스를 제공한다.

요구사항에 대해 아래와 같이 구현하였다.

```java
public interface SAP {
    void send(Invoice invoice);
}


public class SAPInvoiceSender {
    private final InvoiceFilter filter;
    private final SAP sap;

    public SAPInvoiceSender(InvoiceFilter filter, SAP sap) {
        this.filter = filter;
        this.sap = sap;
    }

    public void sendLowValuedInvoices() {
        List<Invoice> lowValuedInvoices = filter.lowValueInvoices();
        for(Invoice invoice : lowValuedInvoices) {
            sap.send(invoice);
        }
    }
}
```

이 클래스에 대한 테스트를 해보자.
여기서 테스트 해야 할 것은 작은 값의 송장이 모두 SAP에 전송되는지 확인하는 것이다.
그렇게 하려면 SAP에 있는 send 메서드 호출이 발생했는지 확인하면 된다.
InvoiceFilter에 대한 테스트는 이미 위에서 진행했기 때문에 여기서는 하지 않아도 된다. 따라서 해당 부분은 Stub으로 처리한다.

다음과 같이 테스트 코드를 작성할 수 있을 것이다.

```java
public class SAPInvoiceSenderTest {
    private InvoiceFilter filter = mock(InvoiceFilter.class);
    private Sap sap = mock(SAP.class);

    private SAPInvoiceSender sender = new SAPInvoiceSender(filter, sap);

    @Test
    void sendToSap() {
        Invoice invoice1 = new Invoice("invoice1", 20);
        Invoice invoice2 = new Invoice("invoice2", 99);

        List<Invoice> invoices = Arrays.asList(invoice1, invoice2);

        when(filter.lowValueInvoices()).thenReturn(invoices);

        sender.sendLowValuedInvoices();

        verify(sap).send(invoice1);
        verify(sap).send(invoice2);
    }
}
```

여기서 스텁(stubbing)과 모의(mocking)의 차이를 볼 수 있는데
스텁은 어떤 메서드 호출에 대해 하드 코딩한 값을 반환한다.
모의는 훨씬 더 구체적인 기댓값을 정의 할 수 있게 해준다.

아래와 같이도 사용할 수 있다.

```java
verify(sapm times(2)).send(any(Invoice.class));
verify(sap, times(1)).send(invoice1);
```

작은 값의 송장이 없을 경우에 대한 테스트 코드를 짠다면 다음과 같이 짤 수 있을 것이다.

```java
@Test
void noLowValueInvoices() {
    List<Invoice> invoices = emptyList();
    when(filter.lowValueInvoices()).thenReturn(invoices);

    sender.sendLowValuedInvoices();

    verify(sap, never()).send(any(Invoice.class));
}
```

## 6.2.3 인수 포획

SAP에 송장을 전송하는 기능에 대한 요구사항에 자그마한 변경이 생겼다고 하자.

> SAP은 이제 Invoice 엔티티를 직접 받는 대신 다른 형식으로 전송된 데이터를 받는다. SAP는 고객명, 송장 가격, 생성 ID가 필요하다.
>
> ID는 다음과 같은 형식을 따른다: <날짜><고객코드>
>
> - 날짜는 항상 'MMddyyyy' 형식이어야 한다: <월><일><4자리 년도>
> - 고객 코드는 고객 이름의 첫 두 글자다. 고객 이름이 두 글자보다 짧으면 'X'로 한다.

SAP 인터페이스를 바꿔서 SapInvoice 엔티티를 받을 수 있도록 구현한다.

```java
public class SapInvoice {
    private final String customer;
    private final int value;
    private final String id;

    public SapInvoice(String customer, int value, String id) {
        // 생성자
    }

    // 게터
}

public interface SAP {
    void send(SapInvoice invoice);
}

public class SAPInvoiceSender {
    private final InvoiceFilter filter;
    private final SAP sap;

    public SAPInvoiceSender(InvoiceFilter filter, SAP sap) {
        this.filter = filter;
        this.sap = sap;
    }

    public void sendLowValuedInvoices() {
        List<Invoice> lowValuedInvoices = filter.lowValueInvoices();
        for(Invoice invoice : lowValuedInvoices) {
            sap.send(InvoiceToSapInvoiceConverter.convert(invoice));
        }
    }
}

public class InvoiceToSapInvoiceConverter {
    public static SapInvoice convert(Invoice invoice) {
        String customer = invoice.getCustomer();
        int value = invoice.getValue();
        String sapId = generateId(invoice);

        return new SapInvoice(customer, value, sapId);
    }

    private static String generatedId(Invoice invoice) {
        String date = LocalDate.now().format(DateTimeFormatter.ofPattern("MMMddyyyy"));
        String customer = invoice.getCustomer();

        return date + (customer.length() >= 2 ? customer.substring(0, 2) : "X")
    }
}
```

위 코드에 대해서 여러 Invoice 인스턴스를 만들어서 convert 메소드를 호출하고 반환된 SapInvoice가 올바른지 단언해보자.

ParameterizedTest와 CsvSource 어노테이션을 이용하면 쉽게 여러 인스턴스를 만들 수 있고
모키토의 인수 포획기(argument captor)를 사용하면 모의 객체에 전달된 특정 객체를 얻을 수 있도록 해준다.

```java
@ParameterizedTest
@CsvSource({
    "Username,Us",
    "U,X"
})
void sendToSapWithTheGeneratedId(String customer, String customerCode) {
    Invoice invoice = new Invoice(customer, 20);

    List<Invoice> invoices = Arrays.asList(invoice);
    when(filter.lowValueInvoices()).thenReturn(invoices);

    sender.sendLowValuedInvoices();

    ArgumentCaptor<SapINvoice> captor = ArgumentCaptor.forClass(SapInvoice.class);

    verify(sap).send(captor.capture());

    SapInvoice generatedSapInvoice = captor.getValue();

    String date = LocalDate.now().format(DateTimeFormatter.ofPattern("MMddyyyy"));
    assertThat(generatedSapInvoice).isEqualTo(new SapInvoice(customer, 20, date + customerCode));
}
```
